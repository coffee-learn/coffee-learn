// Generated by CoffeeScript 1.8.0
(function() {
  var Matrix;

  module.exports.Matrix = Matrix = (function() {
    function Matrix(array) {
      this.matrix = array;
    }

    Matrix.prototype.matrix = function() {
      return this.matrix;
    };

    Matrix.prototype.row = function() {
      return this.matrix.length;
    };

    Matrix.prototype.col = function() {
      return this.matrix[0].length;
    };

    Matrix.prototype.T = function() {
      var array, col, row, t_matrix, _i, _j, _ref, _ref1;
      t_matrix = [];
      for (col = _i = 0, _ref = this.col(); 0 <= _ref ? _i < _ref : _i > _ref; col = 0 <= _ref ? ++_i : --_i) {
        array = [];
        for (row = _j = 0, _ref1 = this.row(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; row = 0 <= _ref1 ? ++_j : --_j) {
          array.push(this.matrix[row][col]);
        }
        t_matrix.push(array);
      }
      return new Matrix(t_matrix);
    };

    Matrix.prototype.inv = function() {
      var INV, M, N, col, i, j, k, mul, n, pivot, row, _i, _j, _k, _l, _len, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (this.col() !== this.row()) {
        throw new Error('matrix dimensions are not valid');
      }
      M = JSON.parse(JSON.stringify(this.matrix));
      N = this.row();
      for (row = _i = 0; 0 <= N ? _i < N : _i > N; row = 0 <= N ? ++_i : --_i) {
        for (col = _j = 0; 0 <= N ? _j < N : _j > N; col = 0 <= N ? ++_j : --_j) {
          if (col === row) {
            M[row].push(1);
          } else {
            M[row].push(0);
          }
        }
      }
      for (i = _k = 0; 0 <= N ? _k < N : _k > N; i = 0 <= N ? ++_k : --_k) {
        pivot = M[i][i];
        for (j = _l = 0, _ref = 2 * N; 0 <= _ref ? _l < _ref : _l > _ref; j = 0 <= _ref ? ++_l : --_l) {
          M[i][j] = (1 / pivot) * M[i][j];
        }
        for (k = _m = _ref1 = i + 1; _ref1 <= N ? _m < N : _m > N; k = _ref1 <= N ? ++_m : --_m) {
          mul = M[k][i];
          for (n = _n = i, _ref2 = 2 * N; i <= _ref2 ? _n < _ref2 : _n > _ref2; n = i <= _ref2 ? ++_n : --_n) {
            M[k][n] = M[k][n] - mul * M[i][n];
          }
        }
      }
      for (i = _o = _ref3 = N - 1; _ref3 <= 0 ? _o < 0 : _o > 0; i = _ref3 <= 0 ? ++_o : --_o) {
        for (k = _p = _ref4 = i - 1; _ref4 <= 0 ? _p <= 0 : _p >= 0; k = _ref4 <= 0 ? ++_p : --_p) {
          mul = M[k][i];
          for (n = _q = i, _ref5 = 2 * N; i <= _ref5 ? _q < _ref5 : _q > _ref5; n = i <= _ref5 ? ++_q : --_q) {
            M[k][n] = M[k][n] - mul * M[i][n];
          }
        }
      }
      INV = [];
      for (_r = 0, _len = M.length; _r < _len; _r++) {
        row = M[_r];
        INV.push(row.slice(N, +(2 * N) + 1 || 9e9));
      }
      return new Matrix(INV);
    };

    Matrix.zeros = function(row, col, fill) {
      var array, c, matrix, r, _i, _j;
      if (fill == null) {
        fill = 0;
      }
      matrix = [];
      for (r = _i = 0; 0 <= row ? _i < row : _i > row; r = 0 <= row ? ++_i : --_i) {
        array = [];
        for (c = _j = 0; 0 <= col ? _j < col : _j > col; c = 0 <= col ? ++_j : --_j) {
          array.push(fill);
        }
        matrix.push(array);
      }
      return new Matrix(matrix);
    };

    Matrix.identify = function(n, fill) {
      var E, col, row, _i, _j, _ref, _ref1;
      if (n == null) {
        n = 2;
      }
      if (fill == null) {
        fill = 1;
      }
      E = Matrix.zeros(n, n);
      for (row = _i = 0, _ref = E.row; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (col = _j = 0, _ref1 = E.col; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          if (row === col) {
            E.matrix[row][col] = fill;
          }
        }
      }
      return E;
    };

    Matrix.add = function(matrix_A, matrix_B) {
      var answer, col, row, _i, _j, _ref, _ref1;
      if ((matrix_A.row() !== matrix_B.row()) || (matrix_A.col() !== matrix_B.col())) {
        throw new Error('matrix dimensions are not valid');
      }
      answer = [];
      for (row = _i = 0, _ref = matrix_A.row(); 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        answer.push([]);
        for (col = _j = 0, _ref1 = matrix_B.col(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          answer[row][col] = matrix_A.matrix[row][col] + matrix_B.matrix[row][col];
        }
      }
      return new Matrix(answer);
    };

    Matrix.sub = function(matrix_A, matrix_B) {
      var answer, col, row, _i, _j, _ref, _ref1;
      if ((matrix_A.row() !== matrix_B.row()) || (matrix_A.col() !== matrix_B.col())) {
        throw new Error('matrix dimensions are not valid');
      }
      answer = [];
      for (row = _i = 0, _ref = matrix_A.row(); 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        answer.push([]);
        for (col = _j = 0, _ref1 = matrix_B.col(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          answer[row][col] = matrix_A.matrix[row][col] - matrix_B.matrix[row][col];
        }
      }
      return new Matrix(answer);
    };

    Matrix.dot = function(matrix_A, matrix_B) {
      var answer, array, col, i, row, sum, _i, _j, _k, _ref, _ref1, _ref2;
      if (matrix_A.col() !== matrix_B.row()) {
        throw new Error('matrix dimensions are not valid');
      }
      answer = [];
      for (row = _i = 0, _ref = matrix_A.row(); 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        array = [];
        for (col = _j = 0, _ref1 = matrix_B.col(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          sum = 0.0;
          for (i = _k = 0, _ref2 = matrix_A.col(); 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            sum += matrix_A.matrix[row][i] * matrix_B.matrix[i][col];
          }
          array.push(sum);
        }
        answer.push(array);
      }
      return new Matrix(answer);
    };

    Matrix.norm = function(matrix) {
      var col, row, square, _i, _j, _len, _len1, _ref;
      square = 0;
      _ref = matrix.matrix;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          col = row[_j];
          square += col * col;
        }
      }
      return Math.sqrt(square);
    };

    return Matrix;

  })();

}).call(this);
